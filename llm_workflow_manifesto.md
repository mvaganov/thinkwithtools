# How LLMs Change What It Means to Understand Code

## LLMs Hurt Understanding by Averting Testing
Understanding remains the most important commodity a software developer can have. Understanding in software development comes from testing: start with an expectation for code, and then test the expectation by observing actual behavior.

The experimentation process should be familiar to developers. Make a guess, introduce inputs, observe outputs, and compare the results to expectations. This cycle of testing builds the practiced judgment and intuition that distinguishes programmers.
It creates reliable progress. Mastery of this skill is an implicit professional expectation. This is how understanding is earned.

**LLMs, by their nature, unintentionally deemphasize testing. This is a mental hazard.** Little documentation about testing makes LLMs under-represent it in practice. Consistently good code from LLMs punishes skepticism. The medium makes a choice of convenience for you. It doesn't force understanding, so you must experiment intentionally.

## Use LLMs Early, Before You Code
LLMs are not just vending machines for code. The LLM should be used early, while scope is being defined. The tool can help you discover what you don't know. Confusion is a "Technical Debt" which compounds over time with repeated sub-optimal decisions.

Explain what you are trying to solve to the LLM, and ask it to help discover blind spots, weakness in expertise, or poor workflow. This could increase your abilities and improve your scope before you consider a line of code.

## Critique as Intelligence Augmentation
LLMs can help you test and experiment on your own thoughts, with critiques. A code review prompt could at the very least point out easy to miss mistakes in your writing. And in the best case, you could get actionable advice, sourced and adapted from intelligent writing you never would have read otherwise.

Remember that you can read and apply critical feedback at your own pace. You are free to disagree with any LLM suggestions. You can ignore or reframe any implied goals. You can choose how to use this tool as an engine for growth.

## Ownership
You must be aware that LLMs can unintentionally and confidently mislead users with bad knowledge. They optimize for plausible sounding output, not correctness in the real world. Premier LLMs can explain how their own technology *necessarily* causes this behavior.

As an LLM user, you need to be skeptical of LLM output. Bad advice is possible. Turn a new idea into a hypothesis, and test it early. How you respond to the new knowledge is your complete responsibility. Experiment on the new knowledge to understand it.

Once you understand, it becomes knowledge that you own. This is the basis of the Ownership that senior software developers encourage in their teams. Ownership means you can explain, modify, and debug code without the LLM. Hit "Commit", and you own the code for real. If it breaks in production, "AI wrote it" is not an excuse. If you can't explain it, don't commit it. Experiment until you own it. 

## Summary
LLMs can produce code without understanding; growth belongs to developers who choose to earn it.

## Next Steps
The next part is "Software Development Workflow with LLMs", a list of tactics to get value out of LLMs in your programming workflow, while augmenting your intelligence as a developer, without needing a compute token budget afforded to software professionals.

The last part is "Programming with LLM Gotchas and Anti-patterns", a compendium of perverse incentives and specific warnings to help recognize LLM usage habits that harm software development.

---

# Software Development Workflow with LLMs

---

# Programming with LLM Gotchas and Anti-patterns
